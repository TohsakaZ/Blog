## 模糊度固定相关内容

### 研究现状

Ge et.al 2008[[PDF](D:\work\GNSS\实时滤波轨道\Ge2008_Article_ResolutionOfGPSCarrier-phaseAm.pdf)] ([HTML](https://readpaper.com/pdf-annotate/note?noteId=633555761535987712&pdfId=633555715819315200))提出了星间单差(SD UPD)的方法 

核心思路 通过对星间单差模糊度的宽巷和窄巷模糊度的小数部分取均值，估计卫星端的UPD（这里UPD应该是指单差的把？）

研究思路：

1. PPP 相对大网解算来说，可以免去很多无关的计算量。但相对的，无法进行双差DD模糊度的固定，因此东方向上的定位精度较差（这个原因是不是和轨道在Across方向上精度较差原因类似？）
2. PPP的非差（ZD）模糊度较难固定 原因在于UPD（Uncalibrated phase delays) 的存在，也是SD模糊度难以固定的原因（卫星端UPD无法消除）。
3. 多个站的同时段PPP可以在一起联合解算，并通过双差模糊度固定。但这样依然又有计算量的问题。针对双差模糊度固定解算的问题，Ge et.al 2005提出了独立基线解算来降低计算量。
4. 通过观察网解中97%的模糊度都可以被固定，一定程度上说明星间SD模糊度的卫星段小数偏差部分在时空上是偏向稳定的，否则不同测站的星间SD模糊度就难以组成可以固定的DD模糊度

### 代码实现

* 实现流程

  输入数据： 残差文件（为了获取LSQ估计的模糊度参数的弧段和估计值）、观测文件（为了计算MW参数的值）、DCB bias（用于MW计算的时候改正观测值）

  处理流程：

  1. 从残差文件中获取模糊度估值。存储到`this->_nOs_ambs`中（按系统、测站分）

  2. 从观测文件获取MW计算值。存储到`this->_MW_used`中

     * 按测站循环

     * 按系统循环

     * 按时间循环

       这里根据之前存储的**模糊度估值**用到的时间节点，获取对应时间节点上对应的MW值

     * 按卫星循环，将获取到的MW值存储到`this->_MW_used`

     这里存储的MW值单位为周（cycle)，存储的索引为：系统、测站、（卫星和时间对）、相应频率（1为IF，2为L1等等）

  3. 获取公共的测站、卫星列表（模糊度参数、配置文件给的部分）

  4. 遍历基线组星间SD模糊度

     这里基线是指卫星基线，实际上就是卫星对

     这里循环遍历卫星对，对每个卫星对（A,B)，遍历所有测站(REC)，获取该测站上所有卫星A，B的模糊度（存在了`this->_nObs_ambs`中），然后判断是否存在共视弧段，在不小于阈值的情况下，组成一个星间单差模糊度存储在`this->_nSd_ambs`（按系统、测站存储）。

  5. 遍历基线组测站-卫星DD模糊度

     按测站基线循环（这里构建基线的时候首先会构建独立的基线，同样使用了SVD判断矩阵秩亏的方式，这里的算法似乎就可以使用最小生成树算法？）

     * 这里独立独立基线单纯就判断了测站之间的独立性
     * 这里最小生成树算法和矩阵秩亏等价的原因在于，如果矩阵秩亏，意味着一定存在一条基线与其他基线线性相关，即这些基线可以形成环，而最小生成树意味着生成的基线中不会有环的存在。
  
     获取测站1上的SD模糊度，获取测站2上的SD模糊度，判断两个SD模糊度是否属于同一个卫星基线，然后再判断共视时间长度是否满足条件
  
     构建双差模糊度，存储到`this->_nDd_ambs`(按系统、测站基线存储)
  
     这里注意下`this->_nSd_ambs`,`this->_nDd_ambs`存储的重点信息是模糊度的起始时间，所属测站、卫星，以及对`this->nObs_ambs`的索引表 `idx2ow`
  
  6. 计算双差模糊度的值(根据之前的索引表)
  
     * 根据之前存储的索引表，因此从`this->_nOw_ambs`中获取相应DD模糊度的值。
  
     * 根据索引表计算相应DD基线对应的MW模糊度的值
  
       这里使用到了之前存储的`this->_MW_used`的数据
  
       同时确定了MW的sigma值，这个值通过协方差公式推导而来
  
       确认MW值是否可以固定 
  
       * 首先使用置信度（应该是构造检验量然后设置置信度的方式？）的方式进行判断
       * 其次判断小数部分阈值是否小于0.15 （为什么这里是0.15？
  
     * 计算NL模糊度的值
  
       需要注意的是这里直接根据之前固定的MW模糊度值和原始模糊度值就可以计算（这里用的是MW模糊度值直接进行了取整，使用round）
  
       `amb.NL_value = amb.value / (length_4th)-round(amb.MW_value) * length_3rd / length_2nd;`
       $$
       b_{nk,l}^{i,j}=\frac{f1+f2}{f1}b_{ck,l}^{i,j}-\frac{f2}{f1+f2}n_{wk,l}^{i,j}
       $$
       
  
       然后固定NL模糊度，方法和固定MW模糊度的方式一致
  
  7. 划分模糊度，根据WL、NL的固定与否进行类型划分
  
     将`this->_nDd_ambs`划分称以下下三类
  
     * WL、NL都固定 （`this->_nDd_ambs`）
     * 只有WL固定（`this->_nDd_ambs_fix_WL`）
     * 都没有固定（`this->_nDd_ambs_fix_No`）
  
  8. 确定独立模糊度集合
  
     > 这里对上述的三类模糊度都作了独立模糊度集的判断
  
     这里判断独立的方法是通过SVD分解的方式判断，即遍历所有的模糊度，构造当前的的模糊度集合的构造矩阵，如果构造矩阵秩亏，说明新加入的模糊度和当前模糊度集合的模糊度不独立。不过这里的判断是在每条独立基线上进行相应判断
  
     判断SVD的方式是否需要改成最小生成树
  
     * 如果改成最小生成树，那问题是不是直接等价于搜索各自测站上的独立SD模糊度，因为DD模糊度肯定不由同个测站的两个SD模糊度组成
  
  9. 输出模糊度固定的文件
  
     * 这里虽然在输出过程中会判断当前的DD模糊度属于全部固定、部分固定还是完全固定，但是由于输出数据中只包含了已经固定的模糊度（即只输出了`this->_nDd_ambs`的结果），因此固定解文件中只有已经固定的双差模糊度
     
     * 需要注意这里的数据结构转换：
     
     `t_gallambs`（这是双差模糊度固定算法中使用的数据结构） -> `t_gambcon`（这个是模糊度固定文件的基础数据结构，以及进行增加模糊度固定约束方程的时候所使用的数据结构） 同时这两个数据结构本质信息都是基于`t_gamb_Dd`数据结构
     
     t_gambfixXX 类都是模糊度固定的算法，本质是模糊度固定算法（单差、双差等）流程的一个集合。
     
     而，t_gallambs才是核心的存储了了模糊度固定数据信息的类结构，同时提供了一些必要的操作（组合模糊度，模糊度固定，挑选共视卫星等操作）

### 关键点

从代码实现中可以看到双差模糊度几个算法实现的关键点：

* 如何判定能否组成基线（共视时间、基线距离）
* 如何判断所租基线的独立性
* 如何构造获取WL、NL的值（这里从残差recover文件中获取后，直接按Ge et.al 2008[[PDF](D:\work\GNSS\实时滤波轨道\Ge2008_Article_ResolutionOfGPSCarrier-phaseAm.pdf)]中所述方法进行组合）
* 如何判断WL、NL模糊度能否被固定（置信度、小数部分的阈值）
* 算法效率等

### SRIF实现模糊度固定

所需要的数据：已经计算好的模糊度值、观测值（DCB改正后的）

然后组基线（确定DD模糊度，以及弧段）

然后计算MW值、WL值、NL值，判断模糊度能否参与固定

