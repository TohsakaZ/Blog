---
title: Prepare
p: daily_task/2021_3_1
date: 2021-03-15 12:03:39
tags:
---

---
##### 面试准备

<!--more-->
* 项目准备
  * [ ] GREAT项目 
    主要使用C/C++封装了导航定位相关的算法，主要使用了一些简单的多态，其余尽量使用数据抽象完成，保证效率。通过智能指针完成指针的相关管理。
    效率提升主要是使用了局部性以提高相应的速率
    设计模式使用了常见的
    工厂模式 根据字符串输入获取对应的子类实例
    桥接模式 根据抽象和实现分离，将不同层次的变化互不影响
    shared_ptr进行指针内存管理
  * [ ] 网页项目
    浏览器发送请求，服务器接收请求 通过wsgi转接到后台进行相应的处理(flask框架)
    基本结构 Model View  Control 分块
    Model主要负责定义相应的数据类型（文章、数据等）
    View负责前端的页面显示（主要是Bootstrap和Jinja2模板引擎将传递过来的数据进行UI展示）
    Control就是处理相应的网页路由（通过获取相应数据传递给模板渲染后返回）
  * [ ] 脚本项目
    一个定时器负责运行相应的流程 app manage utils模块
    数据下载？
    邮件模块实现产品报告？
    日志输出 logging模块

* [ ] 算法
  * [ ] 二分、二叉树四种遍历实现
  * [ ] 冒泡、选择、插入、希尔排序、快排、归并、桶排序


* CPP语法相关
  * [ ] 多态 是如何实现的？虚地址表
    * 通过在每个包含虚函数的类及其派生类中插入一个虚表指针，每个对应类都有相应的虚表,然后每个类的实例的vptr会被初始化指向各自类的虚表
  * [ ] 智能指针
    * 

* 计算机网络相关
  * [ ] TCP协议如何保持可靠传输（确认号、定时重传、检验和)
    * 检验和用于检验序列是否出现相关差错
    * 序列号用于检验冗余分组
    * 超时重传用于防止确认号的数据丢失
    * 选择重传（SR）和 回退N步用于流水线中的处理  GBN的方式可以采用一个定时器，同时采用累积确认号的方式（这也是TCP协议中采用的方式），但重发N步导致的性能问题主要在于接收方没有缓存，而SR的方式则有缓存，但是发送方需要多个定时器,因此可以认为TCP协议是结合了GBN和SR两种方式，即通过GBN加缓存.
    * 快速重传
  * [ ] TCP协议握手、挥手
    * 三次握手
        握手本质在于确定客户端和服务端的序列号,第三次握手对服务器端相当于验证可以向客户端发送消息（接收到ACK确认号后）
    * 四次挥手
        发送端先发送FIN断开连接请求，等待接收ACK，然后进入等待接收端发送断开ACK的请求，然后发送ACK进入TIME_WAIT（为了确保对方收到断开请求）关闭连接
        接收端收到ACK断开请求，发送ACK进入CLOSE_WAIT,然后发送FIN断开请求，等待接收ACK，然后断开
        这里不能把接收端第二次接收和接收端第三次的发送合并的原因在于发送端很有可能还有信息需要发送，需要等待发送端把信息发送完之后，才能发送确定断开连接的请求
  * [ ] UDP协议
    无需连接，报文段主要包含一个检验和，不可靠的
  * [ ] 流量控制
    * 通过接收端发在报文中存储一个有关rwnd（缓存空间剩余量，来保证发送方的速率小于接收方的缓存读取效率）
  * [ ] 拥塞控制 
    * 本质问题在于如何感受拥塞（通过确认号->不拥塞,超时或冗余->拥塞），和控制发送方的发送速率(反复探测可以接收的发送速率（太快拥塞，太慢不能充分利用带宽))
    * 慢启动、拥塞控制、快速恢复
    
      
* 操作系统相关
  * [ ] 虚拟内存工作原理
    * 本质上就是进行一个地址翻译，本质结构就是通过一个由操作系统管理的多级页表进行管理，采用TLB缓存加速
    * 当物理内存中没有缓存对应虚拟内存时候，会引发缺页错误，从而中断进行内核的加载过程
    * 优点通过页表的权限项，从而对物理内存进行保护
    * Linux实现上 将连续的虚拟内存空间，看做一个区域 通过维护不同的区域提供着虚拟空间的抽象,其中还存放了对应虚拟内存的页表
  * [ ] 进程基本的内存模型：
    * 代码和数据
    * 内存动态分配的堆空间
    * 共享库
    * 用户栈
    * 内核代码和数据结构的区域(其中就包括了页表的地址，该进程的虚拟内存空间区域)
  * [ ] 进程：
    * 每个进程都有独立的页表信息，用于讲本地内存空间翻译到实际物理空间
    * 一个正在运行程序的实例，其程序逻辑流和上下文数据
    * 操作系统通过调度系统来切换不同进程，手段之一通过周期性中断陷入内核程序(上下文切换)
  * [ ] 线程：
    * 一个运行在进程上下文中的逻辑流，包含其自身的线程上下文
  * [ ] 碎片
    * 内部碎片是指分配的空间由于分配器或系统对齐原因导致的分配空间大于实际所需空间的部分
    * 外部碎片指已分配的空闲块，由于不相邻尽管总和大于所需分配空间，但无法使用。
    * 伙伴碎片
  * [ ] I/O多路复用：实现的并行（select/poll/epoll的事件驱动）
    * 本质就是通过阻塞多条I/O流的方式进行实现，（事件驱动就是指某一条I/O流产生了相应的数据) 